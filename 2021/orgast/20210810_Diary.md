## 今日の目標
- web技術Webアプリケーション基礎を終わらせる！
- rails入門①現実の複雑さに対応するを終わらせる！

## 今日の積み上げ
- web技術Webアプリケーション基礎完了
- rails入門①chapter4の半分まで進めた。
Webアプリケーションの３層構造は結構ややこしいです(^^;。明日は現場railsのchapter4を終わらせます！

## web技術 chapter-5
## webアプリの３層構造
webブラウザで動作するアプリケーションをwebアプリケーションという。webアプリは３層構造になっている
- プレゼンテーション層（webブラウザとwebサーバーが担当、クライアントサイドスクリプトが動く）,リクエスト処理を担当（ユーザーへの表示、操作受付）
- アプリケーション層(APサーバーが担当、サーバーサイドスクリプが動く)、業務処理を担当（ユーザーからの命令実行、表示画面の作成）
- データ層(DBサーバーが担当)、データ処理を担当（データの抽出、更新、保管など）
## 負荷分散
3層でサーバープログラムを分けることで、サーバーにかかる負荷を軽減できる。また改修範囲を小さくできることもメリット。
## MVCモデル
モデル、ビュー、コントローラーの構造。改修や機能追加が容易にできる。
## フレームワーク
一般的な処理の流れをひな形として準備されてあるもの。プログラムを開発するときに便利。Java EE,Cake PHP,Ruby on Railsなどが有名。フレームワークを使うことで開発者の力量の差による品質のバラつきも少なくなる。
## Webサーバー
webクライアントに対する窓口の役割を果たすプログラム。静的ページのリクエストであればコンテンツをサーバー内から見つけ、クライアントに転送する。動的処理が必要な場合はAPサーバーに処理を依頼する。
## webクライアント
webサーバーとやりとりを行いwebシステムを利用するためのプログラムのこと。ユーザーとwebサーバーの橋渡し的な役割。最も利用されるのはwebブラウザ。
## クライアントプログラム
ブラウザとは別に、特定のwebアプリケーションに特化した機能を持つクライアントプログラムがあり、スマホアプリなどはそれに当てはまる。
## アプリケーションサーバー（APサーバー）
webアプリケーションの命令処理を行うプログラム。webサーバーから転送されてきたユーザーからのデータを受け取り、サーバーサイドプログラムを実行することでデータベースのデータ検索、データの加工をして、webサーバーに応答を返す。３層構造のアプリケーション層に位置し、３層構造の中では最も多機能なサーバー。セッション管理も担当する。
## セッション管理
ステートフルな処理を行う場合は、アプリケーションサーバーがセッションidを発行してセッション管理を行う。ログイン情報を受け取ったらクライアントにセッションidを送る。それでページ遷移してもログイン情報が保たれる。
## トランザクション管理機能
セッション中に行われる一連の作業の最小単位をトランザクションという。例えばログインしてから宿泊施設の予約を完了するまでの流れのこと。
## データベース管理システム
アプリのデータ管理を行うシステム。
## キャッシュサーバー
リクスエストに対するレスポンスを覚えておく役割をするのがキャッシュサーバーというプログラム。リクエストに対するレスポンスの記憶をキャッシュという。コンテンツキャッシュと、クエリキャッシュがある。どちらもデータベースの負荷を軽くする。
## CDN
世界各地に分散して配置されたキャッシュサーバーの集合体。あらかじめwebサーバーからデータを取得しておき、CDN全体で１台のコンテンツキャッシュサーバーのように動作する。ネットワーク的に最も近いサーバーが対応する。
## AJaxを使った非同期通信
クライアントとサーバーが同調して通信を行うことを同期通信という。同期通信はレスポンス待ちが発生する。この欠点を補うのがAJax。webブラウザ上でjavascriptが直接webサーバーと通信を行い、取得したデータを用いて表示するHTMLを更新する。データのやり取りにはXMLが用いられる。更新に必要なデータのみをやり取りするためサーバーへの負荷を抑えられる。例としてGoogleの検索サジェスト機能（検索候補を表示させる）など。現代においては非同期通信ではJSON形式のデータを返すことが主流。
## webプログラミング
プログラミング言語を使ってwebアプリケーションを開発すること。
### サーバーサイドのプログラミング
DBMSの問い合わせやSQLの知識も必要
### クライアントサイドのプログラミング
webアプリではクライアントはwebブラウザ。どのブラウザでも動くようにすることが重要。
## Web API
webを通じてユーザーではなくプログラムが直接サービスを利用するための窓口。天気予報のアプリなら、webAPIのurlに登録地域情報を送信すると、天気予報サイトのwebサーバーが天気予報情報を返送してくれる。
## マッシュアップ
プログラムが複数のサービスを利用し、それを組み合わせることで新しいwebサービスを生み出すこと。位置情報から取得した天気情報を用いてその日に着る服をお勧めするサービス、位置情報から取得した特売情報とレシピ情報を用いて献立を提案するサービスなど。Googleの地図情報やアマゾンの商品情報などがよく使われる。APIが公開中止になると、アプリが使えなくなるところが注意点。
## CGI
webサーバーがクライアントからの要求に応じてサーバーサイドスクリプトを起動するための仕組み。webサーバー上で実行した時の結果を返す。
## サーバー間の連携
サーバー同士の通信においてもクライアント側とレスポンスを返す側があり、そのプロトコルは様々ある。HTTP,AJP,websocketなど。またAPサーバーとDBMSの間で通信を行うためODBCというAPIが開発されている。

## 現場rails chapter4
## マイグレーションの適応について
1. マイグレーションファイルを作る
2. そのファイルを`rails db:midrate`でデータベースに反映させる
取り消し作業もファイルを消すだけではデータベースに反映されない。
## データベースの種類
開発用、テスト用、本番環境用がある。デフォルトでは開発環境のデータベースに反映される。
## 本番用、テスト用のデータベースへの反映
- 本番用への反映`RAILS_ENV=production`
- テスト環境への反映`RAILS_ENV=test`
## マイグレーションの自己管理
railsではマイグレーションの履歴を管理しているため、適応してないマイグレーションだけを判別して反映してくれる。
## マイグレーションファイルの変更
ロールバックしてからファイルを変更してあげ直す。
1. `rails db:rollback`（1つ前のバージョンに戻す）`STEP=n`でn回前のバージョンに戻す
2. マイグレーションファイル変更
3. `rails db:migration`
### ※ただしテーブル作成済みのファイルをrollbackデータが全削除されるので要注意！！
# データ内容を制限する
## データ型
データがどんな形式なのかを宣言する
- integer(数値)
- string(短い文字列)
- text(長い文字列)
- boolean(真偽知)
## NOT NULL制約
物理的に空のデータを保存できなくする。
## 他のマイグレーションのやり方
文字数制限`limit`などをつけたいときは追加するカラム(up)と削除するカラム(down)を両方書く
```
  def up
     change_column 〜
  end
  def down
     change_column 〜
  end
```
## ユニークインデックスを作成する
ユニークインデックスはデータの一意性を守るための制約
```
   t.index :name, unique: true
```
※nullはいくらあってもそれぞれ異なる値として認識される
## validation(検証)
データの内容が正しいかどうかをチェックする仕組み。データベース側でのデータ制限も大事。検証でエラーを発見したら、errorsにエラー内容を格納する。
## saveメソッド
データベースに登録、更新を行う前に自動的に検証を行い、エラーが出たらfalseを返す。
## save!メソッド
基本的に登録更新が成功するはずと信じている場面で使う。エラー時は例外を発生させる。
## 検証用ヘルパーメソッド
- presence: true (必須のデータがちゃんと入っているか？)
- numericality: true (数値以外が入っていないか？)
- length: {maxinum:30}
- uniqueness: true (データが一意になっているか？)
- confirmation: true (パスワードやメールアドレスが確認用の入力と一致しているか？)
## render :new
登録用の画面を再び呼び出す
```
    if @task.save
      redirect_to @task,notice:"タスク「#{@task.name}」を登録しました。"
    else
      render :new
    end
```
## @taskをビューに伝える利点
1. フォームに前回操作した値を引き継いで表示できる
2. taskオブジェクトが抱えるエラーをユーザーに表示できる。
## validatonを一行でかく
同じ属性に対しては一行でかける
```
    validates :name,presence: true,length: {maxnum: 30}
```
## errors.present?
検証用のエラーの有無を調べる。
## オリジナルの検証コード
検証ヘルパーで要件を満たせない場合に書く。validateの後にクラスメソッドを渡す。
```
    validate :validate_name_not_including_comma

    private

    def validate_name_not_including_comma
      errors.add(:name,'にカンマを含めることはできません') if name&.include?(',')
    end
```
## valid?メソッド
検証が通ればtrue,通らなければfalseを返す
## コールバック
登録や削除などの重要なイベントの前後に、任意の処理を呼び出す仕組みのこと。名前が入力されてないときに自動的に「名前なし」と入れる処理など（データの正規化）
## コールバックのタイミング
検証の前後や、登録更新の前後など
```
    before_validation :set_nameless_name

    private

    def set_nameless_name
        self.name = '名前なし' if name.blank?
    end
```
## トランザクション
和訳は取引。取引の途中で問題があった場合は最初からやり直す仕組み。

## 現場rails chapter-4 ログイン機能について
# セッション
サーバー側にセッションという仕組みを用意して、1つのブラウザから連続して送られる一連のリクエストの間に「状態」を共有する仕組み。rails ではsessionというメソッドを呼び出すことでセッションにアクセスできる。セッションにデータを入れるには任意のキーを指定して値を入れる。
```
session[:user_id] = @user.id
```
## Cookie
複数のリクエスト間で共有したい「状態」をブラウザ側に保存する。railsではセッション機能はCookieによって成り立っている。cookieを消せばセッションはリセットされる。
## password_digest
パスワードカラムの名前。has_secure_passwordという機能を使った時の命名規則
## has_secure_password
bcryptというgemを使った時のモデルに書く決まり文句。パスワードをハッシュ化するための機能。生のパスワードをデータベースに保存しないため。
## bcrypt
パスワードを暗号化するためのgem。has_secure_passwordを使うと、passwordという属性とpassword_confirmationという属性が追加される。2つの属性の値が一致したら、password_digestにハッシュ化されたパスワードが保存される。
## uniqueness: true
一意制約をモデルに書く時は「uniqueness」となる。
## セッションというリソースを作る。
ログインする=セッションというリソースを作ると捉えて、railsでログイン機能を実装するときはSessionControllerという名前でコントローラーを作る。リソースとは、コントローラーが扱う概念的なデータの事。
## ログインするの流れ(createアクション)
1. 入力されたメールアドレスでユーザーを検索
2. ユーザーが見つかったら、入力されたパスワードをauthenicateメソッドを使って確認。
3. sessionにuser.idを格納。
ログインしてない場合はsession[:user_id]がnil。ログインしていればログイン中のユーザーIDが入っている。以下のコードでユーザーデータを取り出せる。
```
User.find_by(id: session[:user_id])
```
## authenicateメソッド
has_secure_passwordを記述した時に自動追加されたメソッド。引数で受け取ったパスワードをハッシュ化して、Userオブジェクト内に保存されているdigestと一致するか調べる。一致していたらオブジェクト自身を返し、不一致だったらfalseを返す。
## フィルタ（before_action）
アクションを処理する前後に、任意の処理を挟むことができる。特定の状況の時だけアクションが利用できるように制限するために、前処理フィルタが利用される
```
    before_action :login_required
```
## skip_before_action :login_required
無限にredirectされるのを防ぐため、ログイン画面だけはログインしていなくても利用できるようにする。